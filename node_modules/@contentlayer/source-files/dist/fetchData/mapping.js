import * as tracing_1 from "@effect-ts/core/Tracing";
const fileName_1 = "packages/@contentlayer/source-files/src/fetchData/mapping.ts";
import * as core from '@contentlayer/core';
import * as utils from '@contentlayer/utils';
import { identity, pipe, T } from '@contentlayer/utils/effect';
// Use legacy import format since somehow ESM export isn't properly picked up for `date-fns-tz`
import dateFnsTz from 'date-fns-tz';
import { FetchDataError } from '../errors/index.js';
import { getFromDocumentContext } from './DocumentContext.js';
export const makeDocument = ({ rawContent, documentTypeDef, coreSchemaDef, relativeFilePath, contentDirPath, options, }) => (T.mapError_(T.gen(function* ($) {
    const { bodyFieldName, typeFieldName } = options.fieldOptions;
    // const includeBody = documentTypeDef.fieldDefs.some(
    //   (_) => _.name === bodyFieldName && _.isSystemField,
    // )
    const body = utils.pattern
        .match(rawContent)
        .when(rawContentHasBody, (_) => _.body)
        .otherwise(() => undefined);
    const rawData = { ...rawContent.fields, [bodyFieldName]: body };
    const docValues = yield* $(T.forEachParDict_(documentTypeDef.fieldDefs, {
        mapValue: (fieldDef) => getDataForFieldDef({
            fieldDef,
            rawFieldData: rawData[fieldDef.name],
            typeName: documentTypeDef.name,
            coreSchemaDef,
            options,
            relativeFilePath,
            contentDirPath,
        }),
        mapKey: (fieldDef) => T.succeed(fieldDef.name, fileName_1 + ":60:42"),
    }), fileName_1 + ":48:33");
    const _raw = yield* $(getFromDocumentContext('rawDocumentData'), fileName_1 + ":64:28");
    const doc = {
        ...docValues,
        _id: relativeFilePath,
        _raw,
        [typeFieldName]: documentTypeDef.name,
    };
    return doc;
}, fileName_1 + ":37:10"), (error) => error._tag === 'NoSuchNestedDocumentTypeError' || error._tag === 'IncompatibleFieldDataError'
    ? error
    : new FetchDataError.UnexpectedError({ error, documentFilePath: relativeFilePath }), fileName_1 + ":75:15"));
const rawContentHasBody = (_) => 'body' in _ && _.body !== undefined;
export const getFlattenedPath = (relativeFilePath) => relativeFilePath
    // remove extension
    .split('.')
    .slice(0, -1)
    .join('.')
    // remove tailing `/index` or `index`
    .replace(/\/?index$/, '');
// TODO aggregate all "global" params into an effect service
const makeNestedDocument = ({ rawObjectData, fieldDefs, typeName, coreSchemaDef, options, relativeFilePath, contentDirPath, }) => T.gen(function* ($) {
    const objValues = yield* $(T.forEachParDict_(fieldDefs, {
        mapValue: (fieldDef) => getDataForFieldDef({
            fieldDef,
            rawFieldData: rawObjectData[fieldDef.name],
            typeName,
            coreSchemaDef,
            options,
            relativeFilePath,
            contentDirPath,
        }),
        mapKey: (fieldDef) => T.succeed(fieldDef.name, fileName_1 + ":132:40"),
    }), fileName_1 + ":120:31");
    const typeNameField = options.fieldOptions.typeFieldName;
    const obj = { ...objValues, [typeNameField]: typeName, _raw: {} };
    return obj;
}, fileName_1 + ":119:8");
const getDataForFieldDef = ({ fieldDef, rawFieldData, typeName, coreSchemaDef, options, relativeFilePath, contentDirPath, }) => T.gen(function* ($) {
    if (rawFieldData === undefined && fieldDef.default) {
        rawFieldData = fieldDef.default;
    }
    if (rawFieldData === undefined) {
        if (fieldDef.isRequired && !fieldDef.isSystemField) {
            console.error(`Inconsistent data found: ${JSON.stringify(fieldDef)}`);
        }
        return undefined;
    }
    switch (fieldDef.type) {
        case 'nested': {
            const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[fieldDef.nestedTypeName];
            return yield* $(makeNestedDocument({
                rawObjectData: rawFieldData,
                fieldDefs: nestedTypeDef.fieldDefs,
                typeName: nestedTypeDef.name,
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            }), fileName_1 + ":175:24");
        }
        case 'nested_unnamed':
            return yield* $(makeNestedDocument({
                rawObjectData: rawFieldData,
                fieldDefs: fieldDef.typeDef.fieldDefs,
                typeName: '__UNNAMED__',
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            }), fileName_1 + ":188:24");
        case 'nested_polymorphic': {
            const typeName = rawFieldData[fieldDef.typeField];
            if (!fieldDef.nestedTypeNames.includes(typeName)) {
                return yield* $(T.fail(new FetchDataError.NoSuchNestedDocumentTypeError({
                    documentTypeName: typeName,
                    documentFilePath: relativeFilePath,
                    fieldName: fieldDef.name,
                    validNestedTypeNames: fieldDef.nestedTypeNames,
                }), fileName_1 + ":204:19"), fileName_1 + ":203:26");
            }
            const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[typeName];
            return yield* $(makeNestedDocument({
                rawObjectData: rawFieldData,
                fieldDefs: nestedTypeDef.fieldDefs,
                typeName: nestedTypeDef.name,
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            }), fileName_1 + ":217:24");
        }
        case 'reference':
        case 'reference_polymorphic':
            return rawFieldData;
        case 'list_polymorphic':
        case 'list':
            return yield* $(T.forEachPar_(rawFieldData, (rawItemData) => getDataForListItem({ rawItemData, fieldDef, coreSchemaDef, options, relativeFilePath, contentDirPath }), fileName_1 + ":235:24"), fileName_1 + ":234:24");
        case 'date':
            const value = yield* $(T.tryCatch(() => {
                let dateValue = new Date(rawFieldData);
                if (options.date?.timezone) {
                    dateValue = dateFnsTz.zonedTimeToUtc(dateValue, options.date.timezone);
                }
                return dateValue.toISOString();
            }, () => new FetchDataError.IncompatibleFieldDataError({
                documentFilePath: relativeFilePath,
                documentTypeName: typeName,
                incompatibleFieldData: [[fieldDef.name, rawFieldData]],
            }), fileName_1 + ":241:21"), fileName_1 + ":240:31");
            return value;
        case 'markdown': {
            const isBodyField = fieldDef.name === options.fieldOptions.bodyFieldName;
            const rawDocumentData = yield* $(getFromDocumentContext('rawDocumentData'), fileName_1 + ":261:41");
            // NOTE for the body field, we're passing the entire document file contents to MDX (e.g. in case some remark/rehype plugins need access to the frontmatter)
            // TODO we should come up with a better way to do this
            if (isBodyField) {
                const rawContent = yield* $(getFromDocumentContext('rawContent'), fileName_1 + ":265:38");
                if (rawContent.kind !== 'markdown' && rawContent.kind !== 'mdx')
                    return utils.assertNever(rawContent);
                const html = yield* $(core.markdownToHtml({
                    mdString: rawContent.rawDocumentContent,
                    options: options?.markdown,
                    rawDocumentData,
                }), fileName_1 + ":268:32");
                return { raw: rawFieldData, html };
            }
            else {
                const html = yield* $(core.markdownToHtml({ mdString: rawFieldData, options: options?.markdown, rawDocumentData }), fileName_1 + ":277:32");
                return { raw: rawFieldData, html };
            }
        }
        case 'mdx': {
            const isBodyField = fieldDef.name === options.fieldOptions.bodyFieldName;
            const rawDocumentData = yield* $(getFromDocumentContext('rawDocumentData'), fileName_1 + ":285:41");
            // NOTE for the body field, we're passing the entire document file contents to MDX (e.g. in case some remark/rehype plugins need access to the frontmatter)
            // TODO we should come up with a better way to do this
            if (isBodyField) {
                const rawContent = yield* $(getFromDocumentContext('rawContent'), fileName_1 + ":289:38");
                if (rawContent.kind !== 'mdx' && rawContent.kind !== 'markdown')
                    return utils.assertNever(rawContent);
                const code = yield* $(core.bundleMDX({
                    mdxString: rawContent.rawDocumentContent,
                    options: options?.mdx,
                    contentDirPath,
                    rawDocumentData,
                }), fileName_1 + ":292:32");
                return { raw: rawFieldData, code };
            }
            else {
                const code = yield* $(core.bundleMDX({ mdxString: rawFieldData, options: options?.mdx, contentDirPath, rawDocumentData }), fileName_1 + ":302:32");
                return { raw: rawFieldData, code };
            }
        }
        case 'boolean':
        case 'string':
        case 'number':
        case 'json':
        // case 'slug':
        // case 'text':
        // case 'url':
        case 'enum':
            // case 'image':
            return rawFieldData;
        default:
            utils.casesHandled(fieldDef);
    }
}, fileName_1 + ":159:8");
export const testOnly_getDataForFieldDef = getDataForFieldDef;
const getDataForListItem = ({ rawItemData, fieldDef, coreSchemaDef, options, relativeFilePath, contentDirPath, }) => {
    if (typeof rawItemData === 'string') {
        return T.succeed(rawItemData, fileName_1 + ":341:21");
    }
    if (fieldDef.type === 'list_polymorphic') {
        const nestedTypeName = rawItemData[fieldDef.typeField];
        const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[nestedTypeName];
        if (nestedTypeDef === undefined) {
            const validNestedTypeNames = fieldDef.of
                .filter((_) => _.type === 'nested')
                .map((_) => _.nestedTypeName);
            return T.fail(new FetchDataError.NoSuchNestedDocumentTypeError({
                documentTypeName: nestedTypeName,
                documentFilePath: relativeFilePath,
                fieldName: fieldDef.name,
                validNestedTypeNames,
            }), fileName_1 + ":352:20");
        }
        return makeNestedDocument({
            rawObjectData: rawItemData,
            fieldDefs: nestedTypeDef.fieldDefs,
            typeName: nestedTypeDef.name,
            coreSchemaDef,
            options,
            relativeFilePath,
            contentDirPath,
        });
    }
    switch (fieldDef.of.type) {
        case 'nested':
            const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[fieldDef.of.nestedTypeName];
            return makeNestedDocument({
                rawObjectData: rawItemData,
                fieldDefs: nestedTypeDef.fieldDefs,
                typeName: nestedTypeDef.name,
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            });
        case 'nested_unnamed':
            return makeNestedDocument({
                rawObjectData: rawItemData,
                fieldDefs: fieldDef.of.typeDef.fieldDefs,
                typeName: '__UNNAMED__',
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            });
        case 'boolean':
        case 'enum':
        case 'reference':
        case 'string':
            return T.succeed(rawItemData, fileName_1 + ":398:23");
        default:
            return utils.casesHandled(fieldDef.of);
    }
};
//# sourceMappingURL=mapping.js.map